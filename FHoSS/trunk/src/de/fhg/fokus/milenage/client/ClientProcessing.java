/*
 * $Id$
 *
 * Copyright (C) 2004-2006 FhG Fokus
 *
 * This file is part of Open IMS Core - an open source IMS CSCFs & HSS
 * implementation
 *
 * Open IMS Core is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * For a license to use the Open IMS Core software under conditions
 * other than those described here, or to purchase support for this
 * software, please contact Fraunhofer FOKUS by e-mail at the following
 * addresses:
 *     info@open-ims.org
 *
 * Open IMS Core is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * It has to be noted that this Open Source IMS Core System is not
 * intended to become or act as a product in a commercial context! Its
 * sole purpose is to provide an IMS core reference implementation for
 * IMS technology testing and IMS application prototyping for research
 * purposes, typically performed in IMS test-beds.
 *
 * Users of the Open Source IMS Core System have to be aware that IMS
 * technology may be subject of patents and licence terms, as being
 * specified within the various IMS-related IETF, ITU-T, ETSI, and 3GPP
 * standards. Thus all Open IMS Core users have to take notice of this
 * fact and have to agree to check out carefully before installing,
 * using and extending the Open Source IMS Core System, if related
 * patents and licenses may become applicable to the intended usage
 * context. 
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA  
 * 
 */
package de.fhg.fokus.milenage.client;


import java.security.InvalidKeyException;
import java.util.Properties;

import de.fhg.fokus.milenage.Ak;
import de.fhg.fokus.milenage.Amf;
import de.fhg.fokus.milenage.AuthKey;
import de.fhg.fokus.milenage.AuthenticationException;
import de.fhg.fokus.milenage.Autn;
import de.fhg.fokus.milenage.Auts;
import de.fhg.fokus.milenage.Ck;
import de.fhg.fokus.milenage.DigestAKA;
import de.fhg.fokus.milenage.Ik;
import de.fhg.fokus.milenage.Mac;
import de.fhg.fokus.milenage.MacVerificationException;
import de.fhg.fokus.milenage.Nonce;
import de.fhg.fokus.milenage.Op;
import de.fhg.fokus.milenage.Opc;
import de.fhg.fokus.milenage.Rand;
import de.fhg.fokus.milenage.Res;
import de.fhg.fokus.milenage.SimpleSqn;
import de.fhg.fokus.milenage.Sqn;
import de.fhg.fokus.milenage.codec.CoDecException;
import de.fhg.fokus.milenage.kernel.KernelNotFoundException;

/**
 * @author Sebastian Linkiewicz, dev -at- open - ims dot org
 */
public class ClientProcessing {

    public static final String PUBLIC_ID_PROPERTY_NAME = "de.fhg.fokus.ims.PUBLICID";

    public static final String PRIVATE_ID_PROPERTY_NAME = "de.fhg.fokus.ims.PRIVATEID";

    AuthKey secretKey;

    Sqn sqnMs;

    Opc opc;

    Amf amf;

    DigestAKA digestAKA;

    RegistrationSetupSession registrationSession;

    String privateId;

    String publicId;

    /**
     * @param secretKeyString
     * @throws CoDecException
     * @throws CoDecException
     * @throws InvalidKeyException
     */
    private ClientProcessing(AuthKey secretKey, Opc opc, Amf amf, Sqn sqnMs,
            DigestAKA digestAKA) throws CoDecException, InvalidKeyException {
        this.digestAKA = digestAKA;
        this.secretKey = secretKey;
        this.opc = opc;
        this.sqnMs = sqnMs;
        this.amf = amf;
        registrationSession = new RegistrationSetupSession();
    }

    /**
     * Authenticates the server and generates response Res for a specified nonce
     * value
     * 
     * @param nonce
     *            generated by a server
     * @return the AuthenticationResult with requested result and
     *         SynchronizationToken (Auts) in case of synchronization
     * @throws CoDecException
     * @throws InvalidKeyException
     * @throws MacVerificationException
     * @throws InvalidRegistrationSessionStateException
     * @throws AuthenticationException
     */
    public AuthenticationResult processAuthentication(Nonce nonce)
            throws AuthenticationException {
        try {
            Autn autn = nonce.getAutn();
            Rand rand = nonce.getRand();
            Mac mac = autn.getMac();
            //amf = autn.getAmf();
            Ak ak = null;
            if (Ak.USE_AK) {
                ak = digestAKA.fFive(secretKey, rand, opc);
            }
            Sqn sqnHe = autn.extractSqn(ak);

            Mac xMac = digestAKA.fOne(secretKey, rand, opc, sqnHe, amf);
            System.out.println("AMF:   " + amf);
            System.out.println("KEY:   " + secretKey);
            System.out.println("Mac:   " + mac);
            System.out.println("X-Mac: " + xMac);
            if (!xMac.equals(mac)) {
                throw new MacVerificationException();
            }
            sqnMs = sqnMs.calculateNextSqn();
            System.out.println("SqnHe:   " + sqnHe);
            System.out.println("SqnMs:   " + sqnMs);
            Auts auts = null;
            if (ak != null) {
                autn.xorSqn(ak);
            }

            if (!sqnMs.isInRange(sqnHe)) {
                System.out.println("Synchronization case");
                registrationSession.updateStateToSynchronization();
                auts = handleSynchronizationFailure(nonce);
                System.out.println("auts: " + auts);
            } else {
                registrationSession.updateStateToAuthentication();
            }

            Res res = digestAKA.fTwo("Digest-AKAv1-MD5",secretKey, rand, opc);
            return new AuthenticationResult(res, auts);
        } catch (Exception e) {
            registrationSession.updateStateToFailed();
            e.printStackTrace();
            throw new AuthenticationException();
        }
    }

    /**
     * generates an Auts parameter for a specified nonce
     * 
     * @param nonce
     *            nonce generated by a server
     * @return auts value
     * @throws InvalidKeyException
     * @throws CoDecException
     * @throws InvalidRegistrationSessionStateException
     */
    protected Auts handleSynchronizationFailure(Nonce nonce)
            throws InvalidKeyException, CoDecException,
            InvalidRegistrationSessionStateException {
        registrationSession.testSynchronizationState();
        Rand rand = nonce.getRand();
        Ak ak = null;
        if (Ak.USE_AK) {
            ak = digestAKA.fFiveStar(secretKey, rand, opc);
        }

        Mac macS = digestAKA.fOneStar(secretKey, rand, opc, sqnMs);

        Auts auts = new Auts(sqnMs, macS);
        if (ak != null) {
            auts.setAk(ak);
            auts.xorSqn(ak);
        }
        return auts;
    }

    /**
     * generates an Cipher Key parameter for a specified nonce
     * 
     * @param nonce
     *            nonce generated by a server
     * @return the cipher key
     * @throws InvalidKeyException
     * @throws CoDecException
     */
    public Ck generateCk(Nonce nonce) throws InvalidKeyException,
            CoDecException {
        Rand rand = nonce.getRand();
        return digestAKA.fThree(secretKey, rand, opc);
    }

    /**
     * generates an Integrity Key parameter for a specified nonce
     * 
     * @param nonce
     *            nonce generated by a server
     * @return The generated Integrity Key
     * @throws InvalidKeyException
     * @throws CoDecException
     */
    public Ik generateIk(Nonce nonce) throws InvalidKeyException,
            CoDecException {
        Rand rand = nonce.getRand();
        return digestAKA.fFour(secretKey, rand, opc);
    }

    /**
     * @return Returns the current Sequence Number of the mobile station.
     */
    public Sqn getSqnMs() {
        return sqnMs;
    }

    /**
     * @return Returns the privateId.
     */
    public String getPrivateId() {
        return privateId;
    }

    /**
     * @param privateId
     *            The privateId to set.
     */
    protected void setPrivateId(String privateId) {
        this.privateId = privateId;
    }

    /**
     * @return Returns the publicId.
     */
    public String getPublicId() {
        return publicId;
    }

    /**
     * @param publicId
     *            The publicId to set.
     */
    protected void setPublicId(String publicId) {
        this.publicId = publicId;
    }

    public void startRegistrationSession()
            throws InvalidRegistrationSessionStateException {
        registrationSession.updateStateToInit();
    }

    public void endRegistrationSession()
            throws InvalidRegistrationSessionStateException {
        registrationSession.updateStateToEnded();
    }

    public static ClientProcessing getInstance(Properties props)
            throws KernelNotFoundException, InvalidKeyException, CoDecException {
        if (cp == null) {
            String amf = props.getProperty(Amf.PROPERTY_NAME);
            Amf amfObj = null;
            if (amf != null) {
                amfObj = new Amf(amf);
                Amf.DEFAULT_AMF = amf;
            } else {
                amfObj = new Amf(Amf.DEFAULT_AMF);
            }

            String op = props.getProperty(Op.PROPERTY_NAME);
            Op opObj = null;
            if (op != null) {
                opObj = new Op(op);
                Op.DEFAULT_OP = op;
            }

            String sqnMs = props.getProperty(Sqn.PROPERTY_NAME);
            Sqn sqnMsObj = SimpleSqn.createFromLong(Math.abs(Long
                    .parseLong(sqnMs)));

            String rangeString = props.getProperty(Sqn.PROPERTY_SQNRANGE);
            if (rangeString != null) {
                Sqn.SQN_RANGE = Math.abs(Long.parseLong(rangeString));
            }

            String password = props.getProperty(AuthKey.PROPERTY_NAME);
            AuthKey secretKeyObj = AuthKey.getKeyFromPassword(password);

            String kernelClassName = props
                    .getProperty(DigestAKA.PROPERTY_KERNEL_CLASSNAME);
            DigestAKA digAKA = null;
            if (kernelClassName == null) {
                digAKA = new DigestAKA();
            } else {
                digAKA = new DigestAKA(kernelClassName);
            }

            String opc = props.getProperty(Opc.PROPERTY_NAME);
            Opc opcObj = null;
            if (op != null) {
                opcObj = digAKA.generateOp_c(secretKeyObj, opObj);
            } else {
                opcObj = new Opc(opc);
            }

            String useAk = props.getProperty(Ak.PROPERTY_USEAK);
            if (useAk != null) {
                Ak.USE_AK = Boolean.getBoolean(useAk);
            }

            cp = new ClientProcessing(secretKeyObj, opcObj,
                    amfObj, sqnMsObj, digAKA);

            String privateIdString = props
                    .getProperty(ClientProcessing.PRIVATE_ID_PROPERTY_NAME);
            if (privateIdString == null || privateIdString == "") {
                throw new NullPointerException(
                        "Private Id value null not allowed");
            }

            String publicIdString = props
                    .getProperty(ClientProcessing.PUBLIC_ID_PROPERTY_NAME);
            if (publicIdString == null || publicIdString == "") {
                throw new NullPointerException(
                        "Public Id value null not allowed");
            }

            cp.setPrivateId(privateIdString);
            cp.setPublicId(publicIdString);
        }
        return cp;

    }

    private static ClientProcessing cp = null;
}